<!DOCTYPE html>
<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  </head>
  <body>
  <div class="row">
    <div class="cell" style="width:20%; height: 100%; padding: 20px">
    </div>
    <div class="cell">
      <div id="dashboardHeader" style="font-size: 20px">Header</div>
      <div>
        <svg id='blockPyramid'></svg>
      </div>
    </div>
  </div>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    body {
      font-family: "Open Sans", sans-serif;
      font-size: 13px;
    }
    .title {
      padding-left: 10px;
      padding-bottom: 12px;
      padding-top: 10px;
      font-size: 18px;
      color: #787878;
      border-bottom: 1px solid rgb(240, 239, 241)
    }
    .headers {
      padding-left: 10px;
      padding-bottom: 6px;
      padding-top: 4px;
      font-family: "Lato", sans-serif;
      font-size: 11px;
      color: #787878;
      border-bottom: 1px solid rgb(240, 239, 241)
    }
    .row {
      display: table;
      overflow: hidden;
      width: 100%;
    }
    .cell {
      display: table-cell;
    }
    .barCell {
      border-bottom: 1px solid rgb(240, 239, 241)
    }
    .icon {
      top: 50%;
      padding-left: 22px;
    }
  </style>
  <script type="text/javascript" src="block_board.js"></script>
  <script>
  // magic numbers
  const blockSize = 19 // 9px by 9px
  const defaultOpacity = 0.7
  const defaultFadedOpacity = 0.2
  const pyramidHeight = 40 // number of rows
  const lineGrowBy = 20 // number of pixels grown / row
  const lineHeight = 10 // number of pixels
  const linePadding = 1 // number of pixels
  const margins = {
    top: 20,
    left: 0
  }
  const startingFade = 25 // row number
  const startingWidth = 10
  const svgHeight = 750
  const svgWidth = 2000

  const svg = d3.select('#blockPyramid').attr('transform', `translate(${margins.left}, ${margins.top})`)

  function clearBoard () {
    d3.select('#blockPyramid').selectAll('*').remove()
  }

  svg.attr('width', svgWidth).attr('height', svgHeight)


  function addTransitionTime (n) {
    if (n >= startingFade) return (n - startingFade + 1) * 200
    return (pyramidHeight - startingFade + 1) * 200
  }

  // TODO make it DRY to change the # of blocks removed
  function narrowBlockTransition (item) {
    // make blocks fall in descrete rows
    function calculateY (d) {
      const distanceFromRowEnd = d.rowTotal - d.column
      return (distanceFromRowEnd <= 2) ? svgHeight - (100 + 10 * distanceFromRowEnd) : item.attr('y')
    }

    function calculateDelay (d) {
      const distanceFromRowEnd = d.rowTotal - d.column
      let delayMS = (40 - d.row) * 80
      return delayMS - (3 - distanceFromRowEnd) * 500
    }

    item.transition()
      .delay((d) => calculateDelay(d))
      .duration(3000)
      .attr('y', (d) => calculateY(d))
  }

  // TODO make it DRY to change the # of blocks removed
  function bottomBlockTransition (item, numRows = 3) {
    // make blocks fall in descrete rows
    function calculateY (d) {
      const distanceFromBottom = pyramidHeight - d.row
      if (distanceFromBottom <= numRows) {
        return svgHeight - 300 - (distanceFromBottom * 10)
      } else {
        return item.attr('y')
      }
    }

    function calculateDelay (d) {
      const distanceFromBottom = pyramidHeight - d.row
      return distanceFromBottom * 80
    }

    item.transition()
      .delay((d) => calculateDelay(d))
      .duration(3000)
      .attr('y', (d) => calculateY(d))
      .attr('opacity', (d) => (pyramidHeight - d.row <= numRows) ? defaultFadedOpacity : defaultOpacity)
  }

  function moveXY (d, y) {
    return (d.row > 15 && d.column > 40) ? svgHeight : y
  }

  // TODO add easing
  // TODO move them to other columns
  function dropBlocks (item) {
    const y = item.attr('y')
    item.transition()
      .duration(2000)
      .delay((d) => (21 - d.row) * 100 + (41 - d.column) * 50)
      .attr('y', (d) => moveXY(d, y))
  }

  const blockSquareWidth = 50
  const blockSquareHeight = 20

  function buildBlock (options) {
    return svg.append('rect')
      .attr('id', `row${options.row}column${options.column}`)
      .attr('height', blockSize)
      .attr('width', blockSize)
      .attr('x', options.x)
      .attr('y', options.y)
      .attr('opacity', defaultOpacity)
      .attr('fill', '#FF7518')
  }

  function buildBlockSquare (options) {
    let bb = options.bb
    let runningY = 0 // TODO make startingY a variable
    let runningWidth = startingWidth
    for (let i = 0; i < blockSquareHeight; i++) {
      // number of blocks wide the current row of the pyramid will be
      for (let j = 0; j < blockSquareWidth; j++) {
        blockBoard.add({x: j, y: i})
        const x = bb.calcXY(j)
        const y =bb.calcXY(i)
        const block = buildBlock({x: x, y: y, row: j, column: i})
        block.attr('class', (d) => 'row' + i)
          .datum(() => ({row:i + 1, column: j + 1, columnHeight: blockSquareHeight, rowLength: blockSquareWidth}))
        // options.cb(block)
      }
      runningY += blockSize + linePadding
    }
  }

  // TODO fix this
    // check if X and Y are backwards
  function moveRandomBlockRandomly(options) {
    const delay = d3.scaleLinear()
      .domain([0, options.max])
      .range([1000, 1500])
    const bb = options.bb
    const coordinates = bb.getRandomBlock()
    const randomAdjacentCoordinates = bb.getRandomAdjacentXY()
    bb.remove({x: coordinates.x, y: coordinates.y})
    bb.add({x: randomAdjacentCoordinates.x, y: randomAdjacentCoordinates.y})
    const block = d3.select(`#row${coordinates.x}column${coordinates.y}`)
    console.log("block, coordinates.x, coordinates.y", block, coordinates.x, coordinates.y)
    console.log("block.attr('opacity')", block.attr('opacity'))
    d3.select(`#row${coordinates.x}column${coordinates.y}`)
      .attr('id', `row${randomAdjacentCoordinates.x}column${randomAdjacentCoordinates.y}`)
      .attr('opacity', 0.5)
      .transition()
        .duration(500)
        .attr('x', bb.calcXY(randomAdjacentCoordinates.x))
        .attr('y', bb.calcXY(randomAdjacentCoordinates.y))
  }

  function addRandomBlock(bb) {
    const randomAdjacentCoordinates = bb.getRandomAdjacentXY()
    bb.add({x: randomAdjacentCoordinates.x, y: randomAdjacentCoordinates.y})
    let x = bb.calcXY(randomAdjacentCoordinates.x)
    let y = bb.calcXY(randomAdjacentCoordinates.y)
    const block = buildBlock({x: x, y: y})
    block
      .datum(() => ({
        row: randomAdjacentCoordinates.y + 1,
        column: randomAdjacentCoordinates.x + 1,
        columnHeight: blockSquareHeight,
        rowLength: blockSquareWidth
      }))
  }

  let blockBoard = new BlockBoard({
    divider: 20,
    dividerEvery: 10,
    blockSize: blockSize,
    linePadding: linePadding,
    startingX: 0
  })

  buildBlockSquare({cb: dropBlocks, bb: blockBoard})
  for (let i = 0; i < 4000; i++) {
    moveRandomBlockRandomly({bb: blockBoard, idx: i, max: 4000})
  }
  </script>
  </body>
</html>
